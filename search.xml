<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World（很熟悉吧，heihei）</title>
    <url>/2020/10/09/hello-world/</url>
    <content><![CDATA[<p>总算完成了一个小目标。。。</p>
<h2 id="庆幸自己能坚持到现在"><a href="#庆幸自己能坚持到现在" class="headerlink" title="庆幸自己能坚持到现在"></a>庆幸自己能坚持到现在</h2><p>创建博客一方面帮助自己记录学习心得，一方面也能帮助他人解决问题。想想就有些小兴奋</p>
<h3 id="记录想法、记录历程"><a href="#记录想法、记录历程" class="headerlink" title="记录想法、记录历程"></a>记录想法、记录历程</h3><p>这个听起来好虚无缥缈， 每个劝人写作的鸡汤都这样说，有意思吗？是没意思，可是事实确实如此，你体验不到的东西，不代表不存在。<a id="more"></a><br>最典型的莫过于一个场景，你查了很多资料和花费巨大精力，解决了一个很麻烦的问题，然后你很开心，就直接花了一个小时，把今天解决问题的思路、资料、和解决方案、感想一口气写成了一篇文章，发布到了你的博客上。<br>写完之后，你就关掉电脑，休息了。可能过些天很多细节你就忘了，然后你在另外一个项目又碰到了类似的问题，啊啊啊啊啊，棘手啊，怎么办？叮咚！我好像记录了这个问题的解决方案诶，于是，你打开自己的博客，输入关键字，一下就找到了那篇博客，然后看了一眼里面的内容，问题迎刃而解。<br>因为你以往的日记，直接帮你节省了至少半天的时间，这难道不是我们平时遇到的场景吗？如果同样一个人，没写博客，他就要在从新摸索一遍，真的丧啊。（嫖的。。）</p>
<h3 id="班门弄斧一下"><a href="#班门弄斧一下" class="headerlink" title="班门弄斧一下"></a>班门弄斧一下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GLDaoImpl implements GLDao &#123;</span><br><span class="line">    private JdbcTemplate template &#x3D;new JdbcTemplate(JDBCutil.getDataSource());</span><br><span class="line">    @Override</span><br><span class="line">    public GL logingl(GL loginss)&#123;</span><br><span class="line">        &#x2F;&#x2F;使用JDBC操作数据库</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql&#x3D;&quot;select * from gl where username&#x3D;? and password&#x3D;?&quot;;</span><br><span class="line">            GL user &#x3D; template.queryForObject</span><br><span class="line">                    (sql, new BeanPropertyRowMapper&lt;GL&gt;(GL.class),</span><br><span class="line">                            loginss.getUsername(), loginss.getPassword());</span><br><span class="line">            return user;</span><br><span class="line">        &#125; catch (DataAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="付出总会有回报，这句话不骗人，坚持下来也是一种能力，曾国藩说：世间最容易的是坚持二字，最难的也是坚持二字，成了可成大事。-普通人，更要珍惜和规划自己的有效时间，本就不长的人生里，在互联网里务必留下你精彩的财富！"><a href="#付出总会有回报，这句话不骗人，坚持下来也是一种能力，曾国藩说：世间最容易的是坚持二字，最难的也是坚持二字，成了可成大事。-普通人，更要珍惜和规划自己的有效时间，本就不长的人生里，在互联网里务必留下你精彩的财富！" class="headerlink" title="付出总会有回报，这句话不骗人，坚持下来也是一种能力，曾国藩说：世间最容易的是坚持二字，最难的也是坚持二字，成了可成大事。 普通人，更要珍惜和规划自己的有效时间，本就不长的人生里，在互联网里务必留下你精彩的财富！"></a>付出总会有回报，这句话不骗人，坚持下来也是一种能力，曾国藩说：世间最容易的是坚持二字，最难的也是坚持二字，成了可成大事。 普通人，更要珍惜和规划自己的有效时间，本就不长的人生里，在互联网里务必留下你精彩的财富！</h3>]]></content>
      <categories>
        <category>第一次</category>
        <category>成长</category>
      </categories>
      <tags>
        <tag>第一次</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>md基础格式</title>
    <url>/2020/10/10/md%E5%9F%BA%E7%A1%80%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="md编写格式"><a href="#md编写格式" class="headerlink" title="md编写格式"></a>md编写格式</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用标题是需要使用#号</p>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>这是第一个段落内容</p>
<p>这是第二个段落内容</p>
<a id="more"></a>
<h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><blockquote>
<p>这是一段引用段落，将会被高亮显示</p>
</blockquote>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://www.baidu.com/">百度</a></p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li>无序列表<ul>
<li>第一层<br>*第二层</li>
</ul>
</li>
<li>无序列表<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2></li>
</ul>
<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表<h2 id="分格线"><a href="#分格线" class="headerlink" title="分格线"></a>分格线</h2></li>
</ol>
<hr>
<hr>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight plain"><figcaption><span>type]</span></figcaption><table><tr><td class="code"><pre><span class="line">代码块</span><br></pre></td></tr></table></figure>
<h2 id="表格用代码块演示"><a href="#表格用代码块演示" class="headerlink" title="表格用代码块演示"></a>表格用代码块演示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表格标题|表格标题|表格标题|表格标题</span><br><span class="line">表格格式 默认对齐 ---|--- 左对齐 :---|:--- 居中对齐 :---:|:---: 右对齐 ---:|---|:</span><br><span class="line">表格内容|表格内容|表格内容|表格内容</span><br></pre></td></tr></table></figure>
<h2 id="表格演示"><a href="#表格演示" class="headerlink" title="表格演示"></a>表格演示</h2><table>
<thead>
<tr>
<th align="center">table1</th>
<th align="center">table1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zhangsan</td>
<td align="center">23</td>
</tr>
<tr>
<td align="center">李四</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">##</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>md基础格式</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务中的组件与技术选型</title>
    <url>/2020/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p>1、服务注册于服务发现<br>    服务注册就是将服务的IP和port注册到注册中心，注册中心为Map，其中key是服务的唯一标识（可以是serviceID，也可以是serviceName）,而value是一个包含ipAndPort的结构体的集合，例如是一个List集合，该集合List集合中存放了指定service所在的所有服务器。<br>        主要实现了服务之间的解耦，如果不使用服务注册中心，那么我们需要将被调用服务的服务器列表直接写在调用服务的配置文件中。这造成了两个服务的直接耦合。之后，在调用服务的时候，通过一定的负载均衡算法，从服务器列表中获取一台服务器进行调用。此时，如果被调用的服务所在的服务器有宕机情况或者新添加了服务器，调用服务也不会发现，除非修改配置文件，之后还需要重启服务器。而使用服务注册和服务发现后，调用服务会及时发现新增的机器或者宕掉的机器，并且不需要重启。<br>2、健康检查：<a id="more"></a><br>    健康检查是检查两个东西是否处于正常状态：一个是服务所在服务器的运行状态；一个是服务器本身的运行状态。健康检查的目的其实就是为了在服务发现于服务路由的时候，可以将服务的调用请求发送到处于健康状态的机器上，不至于使服务器调用因为请求被发送到不健康的机器上而失败。<br>        常见的检查技术：Consul、Spring Boot和Actuator<br>3、配置管理：<br>    配置管理主要做三件事：在一个地方集中管理，例如在Consul-KV中集中配置，这样可以保护配置安全，例如，开发人员在上线一个项目的时候，只是将配置信息（其中的数据库配置信息是测试环境下的）提交给运维人员，运维人员可以将线上数据库的配置更改到配置文件中，这样开发人员是看不到线上的配置信息的，起到了一定的保护作用。第二实现服务的配置代码与代码的分离，这样在修改了配置信息之后就不需要在编译、打包、部署整个服务。第三热设备，即当修改了配置信息后，不需要重启服务器就可以自动获取修改后的配置信息<br>        常用技术：Consul、Archaius等<br>4、服务通信：<br>    服务之间的相互调用。服务之间的调用协议可以使用TCP协议，也可以使用HTTP协议。而基于HTTP协议的通信方式是Martin Fowler 所推荐的，而且基于HTTP协议的代码要比基于TCP协议的代码好写，因为不需要考虑丢包、粘贴包等底层问题。当然，也可以使用现成的框架来屏蔽这些底层细节，例如Netty。但即使使用了Netty,也远不如直接使用HTTP协议来进行通信。<br>        常用技术有：Netty、Mina、Retrofit、OkHttp和AsyncHttpClient等前两个主要基于TCP协议的通信，后两者基于HTTP协议的通信，其中Retrofit以一种接口的方式封装方法，并且使用动态代理实现方法的调用，使得调用远程方法和调用本地方法一样简单。<br>5、服务路由：<br>    当一个请求过来时，通过服务发现和健康检查选出健康的服务器列表，之后采用一定的负载均衡策略（路由策略）从这些服务器中选出一台，最后将请求发送到这台服务器中。服务器路由通常会包含一个内建的负载均衡器。而且会包含多种负载均衡策略，这些策略都是可插拔的都是可插拔的，并且会在本地缓存一份可用的服务器列表。当然也可以通过一些策略来更新服务器列表，例如定时的使用服务发现技术刷新本地服务列表缓存，进而达到在宕机或者添加新的机器时，本地服务列表缓存可以及时更新。<br>        常用实现技术：Ribbon<br>6、服务容错：<br>    当服务集群中的一台机器宕机，也不会导致整个服务不可用，甚至不会因为联级失败导致多个服务器不可用造成雪崩。在实际开发中，服务器容错是必须要考虑的，不仅要考虑之前说的联级失败问题，还有考虑怎么让宕机的服务器自动由不可用状态转化为可用状态，并且这个状态切换的时间尽可能短。<br>        常用技术：Hystrix<br>7、日志系统：<br>    日志系统主要用于收集散落在各台机器上的日志，并提供高效的存储与查询方式，通过清晰易懂的界面进行结果展示。当然也会提供方便的分析功能。<br>        常用技术：Logback、RLK、Redis、Flume、Hadoop、Kafka等。<br>8、全链路追踪系统：<br>    全链路追踪系统是指在微服务框架中，由于服务比较多，通常需要多个服务彼此协作，这时候就产生了调用链，我们想理清服务之间的依赖关系，可用分析调用链信息，并且最好还能以图形的形式展示出来，否则，即使统计了调用链信息，也不容易分析出依赖关系，而且如果调用链较长，想要找出耗时服务进行调用链信息。也不容易分析出依赖关系。而且如果调用链较长，想要找出耗时的服务器进行优调比较困难，一旦发生错误也很难定位整个环节中那个服务出现了错误，那么可用通过调用链尽快找出发生问题的服务。<br>        常用技术：Zipkin、Grafana、Promethus、Hystrix-Dashboard和Turbine等<br>9、计数监测系统：<br>    在微服务架构中，服务众多需要对这些服务的一系列指标进行记录监控。这样，既可以根据监控数据（例如，CPU使用频率、内存占用率等）将服务调到最优，也可以让我们对自己的服务有一个实时的了解，在发生错误时，可用尽快的处理。<br>        常用技术：Craphite、Grafana、Promethus、Hystrix-Dashboard和Turbine等<br>10、文档输出：<br>    文档输出其实就是将API接口进行文档化，跟简单的说就是通过编写代码的方式来自动的展现出API接口的各种信息。编写代码是开发人员的强项，如果只能将接口以一个清晰的界面展现出来，那么对于开发人员来说就是信手拈来。如果能将接口以一个清晰的界面展现出来，那更好了。开发人员就不必单独写得写文档，尤其不需要刻意的写一个word。用word文档输出接口信息不仅工作量巨大而且容易出错，接口信息一旦发生改动，开发人员就需要手动更改word文档，这就有可能出错。所有使用一个良好的文档输出工具是很有必要的，不仅可用将API接口信息方便及清晰地展现给服务调用端，而且还可以防止在一段时间后连开发人员都忘记了接口信息。<br>        常用工具：Swagger等<br>11、持续集成与持续部署系统：<br>    持续集成于持续部署可以帮助我我们自动管理代码，控制版本；如果没有持续集成于持续部署，我们需要手动将代码打成jar包，手动上传到服务器，手动关掉之前的服务，手动启动jar包进程，如果是按照Docker镜像来部署的话，我们肯能还需要手动将服务打成镜像包，手动将镜像文件push到镜像仓库，手动将镜像文件从镜像仓库pull下来，手动将镜像运行起来。<br>        常用技术：GitLab、Jenkins、Docker、Kubernetes(k8s)、Mesos及Marathon等<br>12、服务网关：<br>    服务网关=路由转发+过滤器<br>        路由转发指接受一切外界请求，将它们转发到后端的微服务上；过滤器指通过类似过滤器的方式在服务网关中完成一系列的横切功能，例如校验、限流及监控等。<br>        为什么需要服务网关呢？这是一个情景：我们要为微服务系统添加权限校验功能，这个代码可以放在三个位置：<br>            § 每个服务自己实现一遍<br>            § 写到一个公共的服务中，然后其他所有服务都依赖这个服务<br>            § 写道服务网关的前置过滤器中，对所有过来的请求进行权限校验。<br>        第一种，缺点太明显，基本不用；第二种，相对于第一种好很多，代码不会有冗余，但是有两个明显缺点：<br>            § 由于每个服务都引入这个公共服务，那么相当于，每个服务中都要引入了相同的权限校验代码，使得每个服务的jar包大小无缘无故增加了一些。而jar包，尤其在使用Docker镜像进行部署的场景中越小越好。<br>            § 由于每个服务都引入了这个公共服务，那么后续升级这个服务就可能比较困难，而且公共服务的功能越多，升级就越困难。的功能越多，升级就越困难。例如，假设要改变校验方式，想让所有的服务都使用新的权限校验，就需要将之前的所有服务都重新引包并编译部署。<br>        网关恰好可以解决这个问题，首先将权限校验的逻辑写在网关的过滤器中，后端服务不需要关注权限校验代码，所有服务的jar包中也不会引入权限校验的逻辑从而不会增加jar包大小；其次，如果想要修改权限校验的逻辑，只需要修改网关中的权限校验过滤器即可，而不需要升级已存在的服务。<br>            常用技术：Zuul、Kong<br>13、服务编排：<br>    服务编排主要是基于容器技术来实现一个服务的自动容错功能。例如，我们指定一个service有三个容器实例比较适合，如果少于三个，服务编排系统会自动创建容器实例达到三个。假设我们指定当CPU使用率达到90%时，需要在启动一个容器进行容错处理，服务编排系统可以自动做这件事。当下热门的服务编排系统又Kubernetes、Mesos+Marathon等。前者发展势头迅猛，对微服务中的概念抽象得比较好，但是还未经过大量考验，在生成环境中使用需谨慎；后者出现比较早，在生产环境中久经考验，但其对微服务的概念抽象得不太好。按需而来。</p>
]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务概述</title>
    <url>/2020/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>微服务架构风格是将一个单位的应用程序开发拆分为一组“小”<br>的服务。这里说的“小”是以业务边界来区分的，而不是根据代码的多少来区分。每个服务都运行在一个单独的进程中，服务之间通过轻量级的机制进行通信，例如使用HTTP资源接口；每个服务都可以通过全自动化的部署机制来独立部署；微服务中的各个服务可以以多种语言来编写，但是在实际开发中，由于各个公司的技术栈有限,通常会指定一门技术语言，例如Java；每个服务都可以使用不同数据存储技术，例如MySQL、Cassandra（开源分布式NoSQL数据库系统）及MongoDB（分布式文件存储的数据库），但为了同一，通常使用同一种存储技术。<a id="more"></a></p>
<h2 id="为什么需要微服务"><a href="#为什么需要微服务" class="headerlink" title="为什么需要微服务"></a>为什么需要微服务</h2><div align="center">
<img src="/2020/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%BF%B0/java.png" width="350" height="250">
</div>

<p>左边是单体架构图，右边是微服务架构图。传统的单结构主要包括三个部分：一个展示层，用于将一些信息展示给客户端或者为客户端人员提供一些交互；一个数据存储层，通常就是提供一个数据库，用于存储一些需要持续化的数据：最后一部分，是一个服务端的应用程序，该程序主要用于处理请求，执行业务逻辑、操作数据库，以及将相关结果返回给前端等，所有请求都在一个进程中处理，而且水平扩展也很简单，只需要多添加几台部署了该服务的机器，之后在这些服务器的前边部署一台负载均衡器就可以了。<br>单体结构的问题：<br>业务逻辑多写在了一个应用service中，因此只要对该service进行修改，哪怕只是添加了一行代码，都需要编译打包部署到整个应用。<br>假设整个应用中只有一个接口到达了瓶颈，我们想要水平扩展该接口，这时候只能通过水平扩展整个应用来达到目的<br>随着程序的规模增加，即使我们使用Maven进行模块化开发，也很难保证对一个模块的修改不会影响其他模块。<br>微服务架构的缺点：<br>微服务将一个整体应用拆解成了一些列的服务，这样不可避免的将会在不同的服务中存在一些冗余代码，例如，在service1和service2中都用到了Redis集群，可能就需要在两个service中都编写一个JedisCluster的工具类，而这个工具类的代码几乎是一模的。<br>从零开始搭建一套微服务系统，那么需要掌握的组件技术会比较多，从而开发难度会很大，开发周期会比较长。在开源世界中，有一个比较好的微服务框架:SpringCloud。但是如果使用了SpringCloud，可定制性就远不如自己搭建的微服务系统。另外，及使用SpringCloud，一些系统还是需要自己搭建的，比如日志系统，计数监控系统，这都需要具有一定的技术功底。<br>采用微服务架构个ye’w微服务，拆分的原则就是根据业务拆分，但这个业务有时候很难拆分。</p>
]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>概述</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>本地图片不显示问题</title>
    <url>/2020/10/10/%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="博客图片不显示问题"><a href="#博客图片不显示问题" class="headerlink" title="博客图片不显示问题"></a>博客图片不显示问题</h2><p>修改博客根目录中的_config.yml文件的配置post_asset,其默认为false将其改为true<br>当我们设置结束后，通过hexo new(可简写“n”)新建博客后，会产生一个与文件同名的<br>文件夹。</p>
<a id="more"></a>
<h2 id="下载hexo插件"><a href="#下载hexo插件" class="headerlink" title="下载hexo插件"></a>下载hexo插件</h2><p>在博客根目录下使用npm安装插件(如果显示如图警告可以忽略)<br><img src="/2020/10/10/%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/fsevents.png" alt="警告"><br>这个警告，是应为fsevents是一个可选的依赖项,它仅在mac环境上运行时才<br>使用，如果你使用的是其他系统就会警告。所有我们忽略它</p>
<div align="center">
<img src="/2020/10/10/%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/fenye.jpg" width="250" height="150">
</div>]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>表单提交错误</title>
    <url>/2020/10/12/%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="在编写Servlet实现表单提交程序中，出现-500-java-lang-NoClassDefFoundError-org-apache-commons-collections-FastHashMap报错："><a href="#在编写Servlet实现表单提交程序中，出现-500-java-lang-NoClassDefFoundError-org-apache-commons-collections-FastHashMap报错：" class="headerlink" title="在编写Servlet实现表单提交程序中，出现 -500 java.lang.NoClassDefFoundError: org/apache/commons/collections/FastHashMap报错："></a>在编写Servlet实现表单提交程序中，出现 -500 java.lang.NoClassDefFoundError: org/apache/commons/collections/FastHashMap报错：</h2><p>其原因所在就是commons-collection-4.X以上的包中不存在FastHashMap方法，只需要替换成commons-collection-3.2版本即可（记得导入JAR包，然后重启Tomcat）<br>BeanUtil-1.9.3+<br>Collection-3.2.2+<br>loggin-1.2<a id="more"></a><br>下载地址是：<a href="http://commons.apache.org/">JAR</a><br>也可以将BeanUtil-1.9.3+改成BeanUtil-1.8.3<br>需要安装的JAR包：BeanUtil-1.8.3.jar和commons-loggin-1.2.jar</p>
]]></content>
      <categories>
        <category>request</category>
        <category>工具包</category>
        <category>版本问题</category>
      </categories>
      <tags>
        <tag>表单提交</tag>
      </tags>
  </entry>
  <entry>
    <title>悟透JavaScript</title>
    <url>/2020/10/12/%E6%82%9F%E9%80%8FJavaScript/</url>
    <content><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>编程世界里只存在两种基本元素，一个是数据，一个是代码。编程世界就是在数据和代码千丝万缕的纠缠中呈现出无限的生机和活力。<br>数据天生就是文静的，总想保持自己固有的本色；而代码却天生活泼，总想改变这个世界。 <a id="more"></a><br>你看，数据代码间的关系与物质能量间的关系有着惊人的相似。数据也是有惯性的，如果没有代码来施加外力，她总保持自己原来的状态。而代码就象能量，他存在 的唯一目的，就是要努力改变数据原来的状态。在代码改变数据的同时，也会因为数据的抗拒而反过来影响或改变代码原有的趋势。甚至在某些情况下，数据可以转 变为代码，而代码却又有可能被转变为数据，或许还存在一个类似E=MC2形式的数码转换方程呢。然而，就是在数据和代码间这种即矛盾又统一的运转中，总能 体现出计算机世界的规律，这些规律正是我们编写的程序逻辑。<br>不过，由于不同程序员有着不同的世界观，这些数据和代码看起来也就不尽相同。于是，不同世界观的程序员们运用各自的方法论，推动着编程世界的进化和发展。<br>众所周知，当今最流行的编程思想莫过于面向对象编程的思想。为什么面向对象的思想能迅速风靡编程世界呢？因为面向对象的思想首次把数据和代码结合成统一 体，并以一个简单的对象概念呈现给编程者。这一下子就将原来那些杂乱的算法与子程序，以及纠缠不清的复杂数据结构，划分成清晰而有序的对象结构，从而理清 了数据与代码在我们心中那团乱麻般的结。我们又可以有一个更清晰的思维，在另一个思想高度上去探索更加浩瀚的编程世界了。<br>在五祖弘忍讲授完《对象真经》之后的一天，他对众弟子们说：“经已讲完，想必尔等应该有所感悟，请各自写个偈子来看”。大弟子神秀是被大家公认为悟性最高 的师兄，他的偈子写道：“身是对象树，心如类般明。朝朝勤拂拭，莫让惹尘埃！”。此偈一出，立即引起师兄弟们的轰动，大家都说写得太好了。只有火头僧慧能 看后，轻轻地叹了口气，又随手在墙上写道：“对象本无根，类型亦无形。本来无一物，何处惹尘埃？”。然后摇了摇头，扬长而去。大家看了慧能的偈子都说： “写的什么乱七八糟的啊，看不懂”。师父弘忍看了神秀的诗偈也点头称赞，再看慧能的诗偈之后默然摇头。就在当天夜里，弘忍却悄悄把慧能叫到自己的禅房，将 珍藏多年的软件真经传授于他，然后让他趁着月色连夜逃走…<br>后来，慧能果然不负师父厚望，在南方开创了禅宗另一个广阔的天空。而慧能当年带走的软件真经中就有一本是《JavaScript真经》！</p>
<h2 id="回归简单"><a href="#回归简单" class="headerlink" title="回归简单"></a>回归简单</h2><p>要理解JavaScript，你得首先放下对象和类的概念，回到数据和代码的本原。前面说过，编程世界只有数据和代码两种基本元素，而这两种元素又有着纠缠不清的关系。JavaScript就是把数据和代码都简化到最原始的程度。<br>JavaScript中的数据很简洁的。简单数据只有 undefined, null, boolean, number和string这五种，而复杂数据只有一种，即object。这就好比中国古典的朴素唯物思想，把世界最基本的元素归为金木水火土，其他复杂 的物质都是由这五种基本元素组成。<br>JavaScript中的代码只体现为一种形式，就是function。<br>注意：以上单词都是小写的，不要和Number, String, Object, Function等JavaScript内置函数混淆了。要知道，JavaScript语言是区分大小写的呀!<br>任何一个JavaScript的标识、常量、变量和参数都只是unfined, null, bool, number, string, object 和 function类型中的一种，也就typeof返回值表明的类型。除此之外没有其他类型了。<br>先说说简单数据类型吧。<br>undefined:   代表一切未知的事物，啥都没有，无法想象，代码也就更无法去处理了。<br>                      注意：typeof(undefined) 返回也是 undefined。<br>                              可以将undefined赋值给任何变量或属性，但并不意味了清除了该变量，反而会因此多了一个属性。</p>
<p>null:            有那么一个概念，但没有东西。无中似有，有中还无。虽难以想象，但已经可以用代码来处理了。<br>                      注意：typeof(null)返回object，但null并非object，具有null值的变量也并非object。</p>
<p>boolean:      是就是，非就非，没有疑义。对就对，错就错，绝对明确。既能被代码处理，也可以控制代码的流程。</p>
<p>number:      线性的事物，大小和次序分明，多而不乱。便于代码进行批量处理，也控制代码的迭代和循环等。<br>                      注意：typeof(NaN)和typeof(Infinity)都返回number 。<br>                              NaN参与任何数值计算的结构都是NaN，而且 NaN != NaN 。<br>                              Infinity / Infinity = NaN 。</p>
<p>string:         面向人类的理性事物，而不是机器信号。人机信息沟通，代码据此理解人的意图等等，都靠它了。</p>
<p>简单类型都不是对象，JavaScript没有将对象化的能力赋予这些简单类型。直接被赋予简单类型常量值的标识符、变量和参数都不是一个对象。</p>
<p>所谓“对象化”，就是可以将数据和代码组织成复杂结构的能力。JavaScript中只有object类型和function类型提供了对象化的能力。</p>
<h2 id="没有类"><a href="#没有类" class="headerlink" title="没有类"></a>没有类</h2><p>object就是对象的类型。在JavaScript中不管多么复杂的数据和代码，都可以组织成object形式的对象。<br>但JavaScript却没有 “类”的概念！<br>对于许多面向对象的程序员来说，这恐怕是JavaScript中最难以理解的地方。是啊，几乎任何讲面向对象的书中，第一个要讲的就是“类”的概 念，这可是面向对象的支柱。这突然没有了“类”，我们就象一下子没了精神支柱，感到六神无主。看来，要放下对象和类，达到“对象本无根，类型亦无形”的境 界确实是件不容易的事情啊。<br>这样，我们先来看一段JavaScript程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var life &#x3D; &#123;&#125;;</span><br><span class="line">   for(life.age &#x3D; 1; life.age &lt;&#x3D; 3; life.age++)</span><br><span class="line">   &#123;</span><br><span class="line">       switch(life.age)</span><br><span class="line">       &#123;</span><br><span class="line">           case 1: life.body &#x3D; &quot;卵细胞&quot;;</span><br><span class="line">                   life.say &#x3D; function()&#123;alert(this.age+this.body)&#125;;</span><br><span class="line">                   break;</span><br><span class="line">           case 2: life.tail &#x3D; &quot;尾巴&quot;;</span><br><span class="line">                   life.gill &#x3D; &quot;腮&quot;;</span><br><span class="line">                   life.body &#x3D; &quot;蝌蚪&quot;;</span><br><span class="line">                   life.say &#x3D; function()&#123;alert(this.age+this.body+&quot;-&quot;+this.tail+&quot;,&quot;+this.gill)&#125;;</span><br><span class="line">                   break;</span><br><span class="line">           case 3: delete life.tail;</span><br><span class="line">                   delete life.gill;</span><br><span class="line">                   life.legs &#x3D; &quot;四条腿&quot;;</span><br><span class="line">                   life.lung &#x3D; &quot;肺&quot;;</span><br><span class="line">                   life.body &#x3D; &quot;青蛙&quot;;</span><br><span class="line">                   life.say &#x3D; function()&#123;alert(this.age+this.body+&quot;-&quot;+this.legs+&quot;,&quot;+this.lung)&#125;;</span><br><span class="line">                   break;</span><br><span class="line">       &#125;;</span><br><span class="line">       life.say();</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>这段JavaScript程序一开始产生了一个生命对象life，life诞生时只是一个光溜溜的对象，没有任何属性和方法。在第一次生命过程中，它有了 一个身体属性body，并有了一个say方法，看起来是一个“卵细胞”。在第二次生命过程中，它又长出了“尾巴”和“腮”，有了tail和gill属性， 显然它是一个“蝌蚪”。在第三次生命过程中，它的tail和gill属性消失了，但又长出了“四条腿”和“肺”，有了legs和lung属性，从而最终变 成了“青蛙”。如果，你的想像力丰富的话，或许还能让它变成英俊的“王子”，娶个美丽的“公主”什么的。不过，在看完这段程序之后，请你思考一个问题：<br>我们一定需要类吗？<br>还记得儿时那个“小蝌蚪找妈妈”的童话吗？也许就在昨天晚，你的孩子刚好是在这个美丽的童话中进入梦乡的吧。可爱的小蝌蚪也就是在其自身类型不断演化过程 中，逐渐变成了和妈妈一样的“类”，从而找到了自己的妈妈。这个童话故事中蕴含的编程哲理就是：对象的“类”是从无到有，又不断演化，最终又消失于无形之 中的…<br>“类”，的确可以帮助我们理解复杂的现实世界，这纷乱的现实世界也的确需要进行分类。但如果我们的思想被“类”束缚住了，“类”也就变成了“累”。想象一 下，如果一个生命对象开始的时就被规定了固定的“类”，那么它还能演化吗？蝌蚪还能变成青蛙吗？还可以给孩子们讲小蝌蚪找妈妈的故事吗？<br>所以，JavaScript中没有“类”，类已化于无形，与对象融为一体。正是由于放下了“类”这个概念，JavaScript的对象才有了其他编程语言所没有的活力。<br>如果，此时你的内心深处开始有所感悟，那么你已经逐渐开始理解JavaScript的禅机了。</p>
<h2 id="函数的魔力"><a href="#函数的魔力" class="headerlink" title="函数的魔力"></a>函数的魔力</h2><p>接下来，我们再讨论一下JavaScript函数的魔力吧。<br>JavaScript的代码就只有function一种形式，function就是函数的类型。也许其他编程语言还有procedure或 method等代码概念，但在JavaScript里只有function一种形式。当我们写下一个函数的时候，只不过是建立了一个function类型 的实体而已。请看下面的程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myfunc()</span><br><span class="line">&#123;</span><br><span class="line">    alert(&quot;hello&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(typeof(myfunc));</span><br></pre></td></tr></table></figure>

<p>这个代码运行之后可以看到typeof(myfunc)返回的是function。以上的函数写法我们称之为“定义式”的，如果我们将其改写成下面的“变量式”的，就更容易理解了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var myfunc &#x3D; function ()</span><br><span class="line">    &#123;</span><br><span class="line">        alert(&quot;hello&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">alert(typeof(myfunc));</span><br></pre></td></tr></table></figure>
<p>这里明确定义了一个变量myfunc，它的初始值被赋予了一个function的实体。因此，typeof(myfunc)返回的也是function。 其实，这两种函数的写法是等价的，除了一点细微差别，其内部实现完全相同。也就是说，我们写的这些JavaScript函数只是一个命了名的变量而已，其 变量类型即为function，变量的值就是我们编写的函数代码体。<br>聪明的你或许立即会进一步的追问：既然函数只是变量，那么变量就可以被随意赋值并用到任意地方啰？<br>我们来看看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myfunc &#x3D; function ()</span><br><span class="line">    &#123;</span><br><span class="line">        alert(&quot;hello&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">myfunc(); &#x2F;&#x2F;第一次调用myfunc，输出hello</span><br><span class="line"></span><br><span class="line">myfunc &#x3D; function ()</span><br><span class="line">    &#123;</span><br><span class="line">        alert(&quot;yeah&quot;);</span><br><span class="line">    &#125;;    </span><br><span class="line">myfunc(); &#x2F;&#x2F;第二次调用myfunc，将输出yeah</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个程序运行的结果告诉我们：答案是肯定的！在第一次调用函数之后，函数变量又被赋予了新的函数代码体，使得第二次调用该函数时，出现了不同的输出。<br>好了，我们又来把上面的代码改成第一种定义式的函数形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myfunc ()</span><br><span class="line"> &#123;</span><br><span class="line">     alert(&quot;hello&quot;);</span><br><span class="line"> &#125;;</span><br><span class="line"> myfunc(); &#x2F;&#x2F;这里调用myfunc，输出yeah而不是hello</span><br><span class="line"> </span><br><span class="line"> function myfunc ()</span><br><span class="line"> &#123;</span><br><span class="line">     alert(&quot;yeah&quot;);</span><br><span class="line"> &#125;;    </span><br><span class="line"> myfunc(); &#x2F;&#x2F;这里调用myfunc，当然输出yeah</span><br></pre></td></tr></table></figure>

<p>按理说，两个签名完全相同的函数，在其他编程语言中应该是非法的。但在JavaScript中，这没错。不过，程序运行之后却发现一个奇怪的现象：两次调用都只是最后那个函数里输出的值！显然第一个函数没有起到任何作用。这又是为什么呢？<br>原来，JavaScript执行引擎并非一行一行地分析和执行程序，而是一段一段地分析执行的。而且，在同一段程序的分析执行中，定义式的函数语句会被提 取出来优先执行。函数定义执行完之后，才会按顺序执行其他语句代码。也就是说，在第一次调用myfunc之前，第一个函数语句定义的代码逻辑，已被第二个 函数定义语句覆盖了。所以，两次都调用都是执行最后一个函数逻辑了。<br>如果把这个JavaScript代码分成两段，例如将它们写在一个html中，并用《script/》（因为解析原因使用《》代替英文的）标签将其分成这样的两块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function myfunc ()</span><br><span class="line">    &#123;</span><br><span class="line">        alert(&quot;hello&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    myfunc(); &#x2F;&#x2F;这里调用myfunc，输出hello</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function myfunc ()</span><br><span class="line">    &#123;</span><br><span class="line">        alert(&quot;yeah&quot;);</span><br><span class="line">    &#125;;    </span><br><span class="line">    myfunc(); &#x2F;&#x2F;这里调用myfunc，输出yeah</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这时，输出才是各自按顺序来的，也证明了JavaScript的确是一段段地执行的。<br>一段代码中的定义式函数语句会优先执行，这似乎有点象静态语言的编译概念。所以，这一特征也被有些人称为：JavaScript的“预编译”。<br>大多数情况下，我们也没有必要去纠缠这些细节问题。只要你记住一点：JavaScript里的代码也是一种数据，同样可以被任意赋值和修改的，而它的值就是代码的逻辑。只是，与一般数据不同的是，函数是可以被调用执行的。<br>不过，如果JavaScript函数仅仅只有这点道行的话，这与C++的函数指针，DELPHI的方法指针，C#的委托相比，又有啥稀奇嘛！然 而，JavaScript函数的神奇之处还体现在另外两个方面：一是函数function类型本身也具有对象化的能力，二是函数function与对象 object超然的结合能力。奇妙的对象先来说说函数的对象化能力。<br>任何一个函数都可以为其动态地添加或去除属性，这些属性可以是简单类型，可以是对象，也可以是其他函数。也就是说，函数具有对象的全部特征，你完全可以把 函数当对象来用。其实，函数就是对象，只不过比一般的对象多了一个括号“()”操作符，这个操作符用来执行函数的逻辑。即，函数本身还可以被调用，一般对 象却不可以被调用，除此之外完全相同。请看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Sing()</span><br><span class="line">&#123;</span><br><span class="line">    with(arguments.callee)</span><br><span class="line">      alert(author + &quot;：&quot; + poem);</span><br><span class="line">&#125;;</span><br><span class="line">Sing.author &#x3D; &quot;李白&quot;;</span><br><span class="line">Sing.poem &#x3D; &quot;汉家秦地月，流影照明妃。一上玉关道，天涯去不归&quot;;</span><br><span class="line">Sing();</span><br><span class="line">Sing.author &#x3D; &quot;李战&quot;;</span><br><span class="line">Sing.poem &#x3D; &quot;日出汉家天，月落阴山前。女儿琵琶怨，已唱三千年&quot;;</span><br><span class="line">Sing();</span><br></pre></td></tr></table></figure>

<p>在这段代码中，Sing函数被定义后，又给Sing函数动态地增加了author和poem属性。将author和poem属性设为不同的作者和诗句，在 调用Sing()时就能显示出不同的结果。这个示例用一种诗情画意的方式，让我们理解了JavaScript函数就是对象的本质，也感受到了 JavaScript语言的优美。<br>好了，以上的讲述，我们应该算理解了function类型的东西都是和object类型一样的东西，这种东西被我们称为“对象”。我们的确可以这样去看待这些“对象”，因为它们既有“属性”也有“方法”嘛。但下面的代码又会让我们产生新的疑惑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var anObject &#x3D; &#123;&#125;;  &#x2F;&#x2F;一个对象</span><br><span class="line">    anObject.aProperty &#x3D; &quot;Property of object&quot;;  &#x2F;&#x2F;对象的一个属性</span><br><span class="line">    anObject.aMethod &#x3D; function()&#123;alert(&quot;Method of object&quot;)&#125;; &#x2F;&#x2F;对象的一个方法</span><br><span class="line">    &#x2F;&#x2F;主要看下面：</span><br><span class="line">    alert(anObject[&quot;aProperty&quot;]);   &#x2F;&#x2F;可以将对象当数组以属性名作为下标来访问属性</span><br><span class="line">    anObject[&quot;aMethod&quot;]();          &#x2F;&#x2F;可以将对象当数组以方法名作为下标来调用方法</span><br><span class="line">    for( var s in anObject)           &#x2F;&#x2F;遍历对象的所有属性和方法进行迭代化处理</span><br><span class="line">        alert(s + &quot; is a &quot; + typeof(anObject[s]));</span><br></pre></td></tr></table></figure>

<p>同样对于function类型的对象也是一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aFunction &#x3D; function() &#123;&#125;;  &#x2F;&#x2F;一个函数</span><br><span class="line">aFunction.aProperty &#x3D; &quot;Property of function&quot;;  &#x2F;&#x2F;函数的一个属性</span><br><span class="line">aFunction.aMethod &#x3D; function()&#123;alert(&quot;Method of function&quot;)&#125;; &#x2F;&#x2F;函数的一个方法</span><br><span class="line">&#x2F;&#x2F;主要看下面：</span><br><span class="line">alert(aFunction[&quot;aProperty&quot;]);   &#x2F;&#x2F;可以将函数当数组以属性名作为下标来访问属性</span><br><span class="line">aFunction[&quot;aMethod&quot;]();          &#x2F;&#x2F;可以将函数当数组以方法名作为下标来调用方法</span><br><span class="line">for( var s in aFunction)           &#x2F;&#x2F;遍历函数的所有属性和方法进行迭代化处理</span><br><span class="line">    alert(s + &quot; is a &quot; + typeof(aFunction[s]));</span><br></pre></td></tr></table></figure>

<p>是的，对象和函数可以象数组一样，用属性名或方法名作为下标来访问并处理。那么，它到底应该算是数组呢，还是算对象？<br>我们知道，数组应该算是线性数据结构，线性数据结构一般有一定的规律，适合进行统一的批量迭代操作等，有点像波。而对象是离散数据结构，适合描述分散的和个性化的东西，有点像粒子。因此，我们也可以这样问：JavaScript里的对象到底是波还是粒子？<br>如果存在对象量子论，那么答案一定是：波粒二象性！<br>因此，JavaScript里的函数和对象既有对象的特征也有数组的特征。这里的数组被称为“字典”，一种可以任意伸缩的名称值对儿的集合。其实， object和function的内部实现就是一个字典结构，但这种字典结构却通过严谨而精巧的语法表现出了丰富的外观。正如量子力学在一些地方用粒子来 解释和处理问题，而在另一些地方却用波来解释和处理问题。你也可以在需要的时候，自由选择用对象还是数组来解释和处理问题。只要善于把握 JavaScript的这些奇妙特性，就可以编写出很多简洁而强大的代码来。</p>
<h2 id="放下对象"><a href="#放下对象" class="headerlink" title="放下对象"></a>放下对象</h2><p>我们再来看看function与object的超然结合吧。<br>在面向对象的编程世界里，数据与代码的有机结合就构成了对象的概念。自从有了对象，编程世界就被划分成两部分，一个是对象内的世界，一个是对象外的世界。 对象天生具有自私的一面，外面的世界未经允许是不可访问对象内部的。对象也有大方的一面，它对外提供属性和方法，也为他人服务。不过，在这里我们要谈到一 个有趣的问题，就是“对象的自我意识”。<br>什么？没听错吧？对象有自我意识？<br>可能对许多程序员来说，这的确是第一次听说。不过，请君看看C++、C#和Java的this，DELPHI的self，还有VB的me，或许你会恍然大悟！当然，也可能只是说句“不过如此”而已。<br>然而，就在对象将世界划分为内外两部分的同时，对象的“自我”也就随之产生。“自我意识”是生命的最基本特征！正是由于对象这种强大的生命力，才使得编程世界充满无限的生机和活力。<br>但对象的“自我意识”在带给我们快乐的同时也带来了痛苦和烦恼。我们给对象赋予了太多欲望，总希望它们能做更多的事情。然而，对象的自私使得它们互相争抢 系统资源，对象的自负让对象变得复杂和臃肿，对象的自欺也往往带来挥之不去的错误和异常。我们为什么会有这么多的痛苦和烦恼呢？<br>为此，有一个人，在对象树下，整整想了九九八十一天，终于悟出了生命的痛苦来自于欲望，但究其欲望的根源是来自于自我意识。于是他放下了“自我”，在对象 树下成了佛，从此他开始普度众生，传播真经。他的名字就叫释迦摩尼，而《JavaScript真经》正是他所传经书中的一本。<br>JavaScript中也有this，但这个this却与C++、C#或Java等语言的this不同。一般编程语言的this就是对象自己，而 JavaScript的this却并不一定！this可能是我，也可能是你，可能是他，反正是我中有你，你中有我，这就不能用原来的那个“自我”来理解 JavaScript这个this的含义了。为此，我们必须首先放下原来对象的那个“自我”。<br>我们来看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function WhoAmI()       &#x2F;&#x2F;定义一个函数WhoAmI</span><br><span class="line">  &#123;</span><br><span class="line">      alert(&quot;I&#39;m &quot; + this.name + &quot; of &quot; + typeof(this));</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  WhoAmI();   &#x2F;&#x2F;此时是this当前这段代码的全局对象，在浏览器中就是window对象，其name属性为空字符串。输出：I&#39;m of object</span><br><span class="line"></span><br><span class="line">  var BillGates &#x3D; &#123;name: &quot;Bill Gates&quot;&#125;;</span><br><span class="line">  BillGates.WhoAmI &#x3D; WhoAmI;  &#x2F;&#x2F;将函数WhoAmI作为BillGates的方法。</span><br><span class="line">  BillGates.WhoAmI();         &#x2F;&#x2F;此时的this是BillGates。输出：I&#39;m Bill Gates of object</span><br><span class="line">  </span><br><span class="line">  var SteveJobs &#x3D; &#123;name: &quot;Steve Jobs&quot;&#125;;</span><br><span class="line">  SteveJobs.WhoAmI &#x3D; WhoAmI;  &#x2F;&#x2F;将函数WhoAmI作为SteveJobs的方法。</span><br><span class="line">  SteveJobs.WhoAmI();         &#x2F;&#x2F;此时的this是SteveJobs。输出：I&#39;m Steve Jobs of object</span><br><span class="line"></span><br><span class="line">  WhoAmI.call(BillGates);     &#x2F;&#x2F;直接将BillGates作为this，调用WhoAmI。输出：I&#39;m Bill Gates of object</span><br><span class="line">  WhoAmI.call(SteveJobs);     &#x2F;&#x2F;直接将SteveJobs作为this，调用WhoAmI。输出：I&#39;m Steve Jobs of object</span><br><span class="line">  </span><br><span class="line">  BillGates.WhoAmI.call(SteveJobs);   &#x2F;&#x2F;将SteveJobs作为this，却调用BillGates的WhoAmI方法。输出：I&#39;m Steve Jobs of object</span><br><span class="line">  SteveJobs.WhoAmI.call(BillGates);   &#x2F;&#x2F;将BillGates作为this，却调用SteveJobs的WhoAmI方法。输出：I&#39;m Bill Gates of object</span><br><span class="line"></span><br><span class="line">  WhoAmI.WhoAmI &#x3D; WhoAmI;     &#x2F;&#x2F;将WhoAmI函数设置为自身的方法。</span><br><span class="line">  WhoAmI.name &#x3D; &quot;WhoAmI&quot;;</span><br><span class="line">  WhoAmI.WhoAmI();            &#x2F;&#x2F;此时的this是WhoAmI函数自己。输出：I&#39;m WhoAmI of function</span><br><span class="line">      </span><br><span class="line">  (&#123;name: &quot;nobody&quot;, WhoAmI: WhoAmI&#125;).WhoAmI();    &#x2F;&#x2F;临时创建一个匿名对象并设置属性后调用WhoAmI方法。输出：I&#39;m nobody of object</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，同一个函数可以从不同的角度来调用，this并不一定是函数本身所属的对象。this只是在任意对象和function元素结合时的一个概念，是种结合比起一般对象语言的默认结合更加灵活，显得更加超然和洒脱。<br>在JavaScript函数中，你只能把this看成当前要服务的“这个”对象。this是一个特殊的内置参数，根据this参数，您可以访问到“这个” 对象的属性和方法，但却不能给this参数赋值。在一般对象语言中，方法体代码中的this可以省略的，成员默认都首先是“自己”的。但 JavaScript却不同，由于不存在“自我”，当访问“这个”对象时，this不可省略！<br>JavaScript提供了传递this参数的多种形式和手段，其中，象BillGates.WhoAmI()和SteveJobs.WhoAmI()这 种形式，是传递this参数最正规的形式，此时的this就是函数所属的对象本身。而大多数情况下，我们也几乎很少去采用那些借花仙佛的调用形式。但只我 们要明白JavaScript的这个“自我”与其他编程语言的“自我”是不同的，这是一个放下了的“自我”，这就是JavaScript特有的世界观。</p>
<h2 id="对象素描"><a href="#对象素描" class="headerlink" title="对象素描"></a>对象素描</h2><p>已经说了许多了许多话题了，但有一个很基本的问题我们忘了讨论，那就是：怎样建立对象？<br>在前面的示例中，我们已经涉及到了对象的建立了。我们使用了一种被称为JavaScript Object Notation(缩写JSON)的形式，翻译为中文就是“JavaScript对象表示法”。<br>JSON为创建对象提供了非常简单的方法。例如，<br>创建一个没有任何属性的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>创建一个对象并设置属性及初始值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#123;name: &quot;Angel&quot;, age: 18, married: false&#125;;</span><br></pre></td></tr></table></figure>

<p>创建一个对象并设置属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var speaker &#x3D; &#123;text: &quot;Hello World&quot;, say: function()&#123;alert(this.text)&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>创建一个更复杂的对象，嵌套其他对象和对象数组等：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var company &#x3D;</span><br><span class="line"> &#123;</span><br><span class="line">     name: &quot;Microsoft&quot;,</span><br><span class="line">     product: &quot;softwares&quot;,</span><br><span class="line">     chairman: &#123;name: &quot;Bill Gates&quot;, age: 53, Married: true&#125;,</span><br><span class="line">     employees: [&#123;name: &quot;Angel&quot;, age: 26, Married: false&#125;, &#123;name: &quot;Hanson&quot;, age: 32, Marred: true&#125;],</span><br><span class="line">     readme: function() &#123;document.write(this.name + &quot; product &quot; + this.product);&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>JSON的形式就是用大括“{}”号包括起来的项目列表，每一个项目间并用逗号“,”分隔，而项目就是用冒号“:”分隔的属性名和属性值。这是典型的字典 表示形式，也再次表明了 JavaScript里的对象就是字典结构。不管多么复杂的对象，都可以被一句JSON代码来创建并赋值。<br>其实，JSON就是JavaScript对象最好的序列化形式，它比XML更简洁也更省空间。对象可以作为一个JSON形式的字符串，在网络间自 由传递和交换信息。而当需要将这个JSON字符串变成一个JavaScript对象时，只需要使用eval函数这个强大的数码转换引擎，就立即能得到一个 JavaScript内存对象。正是由于JSON的这种简单朴素的天生丽质，才使得她在AJAX舞台上成为璀璨夺目的明星。<br>JavaScript就是这样，把面向对象那些看似复杂的东西，用及其简洁的形式表达出来。卸下对象浮华的浓妆，还对象一个眉目清晰！</p>
<h2 id="构造对象"><a href="#构造对象" class="headerlink" title="构造对象"></a>构造对象</h2><p>好了，接下我们来讨论一下对象的另一种创建方法。<br>除JSON外，在JavaScript中我们可以使用new操作符结合一个函数的形式来创建对象。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyFunc() &#123;&#125;;         &#x2F;&#x2F;定义一个空函数</span><br><span class="line">  var anObj &#x3D; new MyFunc();  &#x2F;&#x2F;使用new操作符，借助MyFun函数，就创建了一个对象</span><br></pre></td></tr></table></figure>

<p>JavaScript的这种创建对象的方式可真有意思，如何去理解这种写法呢？<br>其实，可以把上面的代码改写成这种等价形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyFunc()&#123;&#125;;</span><br><span class="line">    var anObj &#x3D; &#123;&#125;;     &#x2F;&#x2F;创建一个对象</span><br><span class="line">    MyFunc.call(anObj); &#x2F;&#x2F;将anObj对象作为this指针调用MyFunc函数</span><br></pre></td></tr></table></figure>

<p>我们就可以这样理解，JavaScript先用new操作符创建了一个对象，紧接着就将这个对象作为this参数调用了后面的函数。其 实，JavaScript内部就是这么做的，而且任何函数都可以被这样调用！但从 “anObj = new MyFunc()” 这种形式，我们又看到一个熟悉的身影，C++和C#不就是这样创建对象的吗？原来，条条大路通灵山，殊途同归啊！<br>君看到此处也许会想，我们为什么不可以把这个MyFunc当作构造函数呢？恭喜你，答对了！JavaScript也是这么想的！请看下面的代码： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)   &#x2F;&#x2F;带参数的构造函数</span><br><span class="line">     &#123;</span><br><span class="line">         this.name &#x3D; name;   &#x2F;&#x2F;将参数值赋给给this对象的属性</span><br><span class="line">         this.SayHello &#x3D; function() &#123;alert(&quot;Hello, I&#39;m &quot; + this.name);&#125;;   &#x2F;&#x2F;给this对象定义一个SayHello方法。</span><br><span class="line">     &#125;;</span><br><span class="line"> </span><br><span class="line">     function Employee(name, salary)     &#x2F;&#x2F;子构造函数</span><br><span class="line">     &#123;</span><br><span class="line">         Person.call(this, name);        &#x2F;&#x2F;将this传给父构造函数</span><br><span class="line">         this.salary &#x3D; salary;       &#x2F;&#x2F;设置一个this的salary属性</span><br><span class="line">         this.ShowMeTheMoney &#x3D; function() &#123;alert(this.name + &quot; $&quot; + this.salary);&#125;;  &#x2F;&#x2F;添加ShowMeTheMoney方法。</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     var BillGates &#x3D; new Person(&quot;Bill Gates&quot;);   &#x2F;&#x2F;用Person构造函数创建BillGates对象</span><br><span class="line">     var SteveJobs &#x3D; new Employee(&quot;Steve Jobs&quot;, 1234);   &#x2F;&#x2F;用Empolyee构造函数创建SteveJobs对象</span><br><span class="line"> </span><br><span class="line">     BillGates.SayHello();   &#x2F;&#x2F;显示：I&#39;m Bill Gates</span><br><span class="line">     SteveJobs.SayHello();   &#x2F;&#x2F;显示：I&#39;m Steve Jobs</span><br><span class="line">     SteveJobs.ShowMeTheMoney();   &#x2F;&#x2F;显示：Steve Jobs $1234</span><br><span class="line"> </span><br><span class="line">     alert(BillGates.constructor &#x3D;&#x3D; Person);  &#x2F;&#x2F;显示：true</span><br><span class="line">     alert(SteveJobs.constructor &#x3D;&#x3D; Employee);  &#x2F;&#x2F;显示：true</span><br><span class="line">     </span><br><span class="line">     alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;显示：false</span><br></pre></td></tr></table></figure>

<p>这段代码表明，函数不但可以当作构造函数，而且还可以带参数，还可以为对象添加成员和方法。其中的第9行，Employee构造函数又将自己接收的 this作为参数调用Person构造函数，这就是相当于调用基类的构造函数。第21、22行还表明这样一个意思：BillGates是由Person构 造的，而SteveJobs是由Employee构造的。对象内置的constructor属性还指明了构造对象所用的具体函数！<br>其实，如果你愿意把函数当作“类”的话，她就是“类”，因为她本来就有“类”的那些特征。难道不是吗？她生出的儿子各个都有相同的特征，而且构造函数也与类同名嘛！<br>但要注意的是，用构造函数操作this对象创建出来的每一个对象，不但具有各自的成员数据，而且还具有各自的方法数据。换句话说，方法的代码体(体现函数 逻辑的数据)在每一个对象中都存在一个副本。尽管每一个代码副本的逻辑是相同的，但对象们确实是各自保存了一份代码体。上例中的最后一句说明了这一实事， 这也解释了JavaScript中的函数就是对象的概念。<br>同一类的对象各自有一份方法代码显然是一种浪费。在传统的对象语言中，方法函数并不象JavaScript那样是个对象概念。即使也有象函数指针、方法指针或委托那样的变化形式，但其实质也是对同一份代码的引用。一般的对象语言很难遇到这种情况。<br>不过，JavaScript语言有大的灵活性。我们可以先定义一份唯一的方法函数体，并在构造this对象时使用这唯一的函数对象作为其方法，就能共享方法逻辑。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SayHello()     &#x2F;&#x2F;先定义一份SayHello函数代码</span><br><span class="line">&#123;</span><br><span class="line">    alert(&quot;Hello, I&#39;m &quot; + this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Person(name)   &#x2F;&#x2F;带参数的构造函数</span><br><span class="line">&#123;</span><br><span class="line">    this.name &#x3D; name;   &#x2F;&#x2F;将参数值赋给给this对象的属性</span><br><span class="line">    this.SayHello &#x3D; SayHello;   &#x2F;&#x2F;给this对象SayHello方法赋值为前面那份SayHello代码。</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var BillGates &#x3D; new Person(&quot;Bill Gates&quot;);   &#x2F;&#x2F;创建BillGates对象</span><br><span class="line">var SteveJobs &#x3D; new Person(&quot;Steve Jobs&quot;);   &#x2F;&#x2F;创建SteveJobs对象</span><br><span class="line"></span><br><span class="line">alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;显示：true</span><br></pre></td></tr></table></figure>

<p>其中，最后一行的输出结果表明两个对象确实共享了一个函数对象。虽然，这段程序达到了共享了一份方法代码的目的，但却不怎么优雅。因为，定义 SayHello方法时反映不出其与Person类的关系。“优雅”这个词用来形容代码，也不知道是谁先提出来的。不过，这个词反映了程序员已经从追求代 码的正确、高效、可靠和易读等基础上，向着追求代码的美观感觉和艺术境界的层次发展，程序人生又多了些浪漫色彩。<br>显然，JavaScript早想到了这一问题，她的设计者们为此提供了一个有趣的prototype概念。</p>
<h2 id="初看原型"><a href="#初看原型" class="headerlink" title="初看原型"></a>初看原型</h2><p>prototype源自法语，软件界的标准翻译为“原型”，代表事物的初始形态，也含有模型和样板的意义。JavaScript中的prototype概念恰如其分地反映了这个词的内含，我们不能将其理解为C++的prototype那种预先声明的概念。<br>JavaScript的所有function类型的对象都有一个prototype属性。这个prototype属性本身又是一个object类型的对 象，因此我们也可以给这个prototype对象添加任意的属性和方法。既然prototype是对象的“原型”，那么由该函数构造出来的对象应该都会具 有这个“原型”的特性。事实上，在构造函数的prototype上定义的所有属性和方法，都是可以通过其构造的对象直接访问和调用的。也可以这么 说，prototype提供了一群同类对象共享属性和方法的机制。<br>我们先来看看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)</span><br><span class="line">  &#123;</span><br><span class="line">      this.name &#x3D; name;   &#x2F;&#x2F;设置对象属性，每个对象各自一份属性数据</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  Person.prototype.SayHello &#x3D; function()  &#x2F;&#x2F;给Person函数的prototype添加SayHello方法。</span><br><span class="line">  &#123;</span><br><span class="line">      alert(&quot;Hello, I&#39;m &quot; + this.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var BillGates &#x3D; new Person(&quot;Bill Gates&quot;);   &#x2F;&#x2F;创建BillGates对象</span><br><span class="line">  var SteveJobs &#x3D; new Person(&quot;Steve Jobs&quot;);   &#x2F;&#x2F;创建SteveJobs对象</span><br><span class="line"></span><br><span class="line">  BillGates.SayHello();   &#x2F;&#x2F;通过BillGates对象直接调用到SayHello方法</span><br><span class="line">  SteveJobs.SayHello();   &#x2F;&#x2F;通过SteveJobs对象直接调用到SayHello方法</span><br><span class="line"></span><br><span class="line">  alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;因为两个对象是共享prototype的SayHello，所以显示：true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序运行的结果表明，构造函数的prototype上定义的方法确实可以通过对象直接调用到，而且代码是共享的。显然，把方法设置到prototype的 写法显得优雅多了，尽管调用形式没有变，但逻辑上却体现了方法与类的关系，相对前面的写法，更容易理解和组织代码。<br>那么，对于多层次类型的构造函数情况又如何呢？<br>我们再来看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)   &#x2F;&#x2F;基类构造函数</span><br><span class="line">     &#123;</span><br><span class="line">         this.name &#x3D; name;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     Person.prototype.SayHello &#x3D; function()  &#x2F;&#x2F;给基类构造函数的prototype添加方法</span><br><span class="line">     &#123;</span><br><span class="line">         alert(&quot;Hello, I&#39;m &quot; + this.name);</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     function Employee(name, salary) &#x2F;&#x2F;子类构造函数</span><br><span class="line">     &#123;</span><br><span class="line">         Person.call(this, name);    &#x2F;&#x2F;调用基类构造函数</span><br><span class="line">         this.salary &#x3D; salary;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     Employee.prototype &#x3D; new Person();  &#x2F;&#x2F;建一个基类的对象作为子类原型的原型，这里很有意思</span><br><span class="line">     </span><br><span class="line">     Employee.prototype.ShowMeTheMoney &#x3D; function()  &#x2F;&#x2F;给子类添构造函数的prototype添加方法</span><br><span class="line">     &#123;         alert(this.name + &quot; $&quot; + this.salary);</span><br><span class="line">     &#125;;</span><br><span class="line"> </span><br><span class="line">     var BillGates &#x3D; new Person(&quot;Bill Gates&quot;);   &#x2F;&#x2F;创建基类Person的BillGates对象</span><br><span class="line">     var SteveJobs &#x3D; new Employee(&quot;Steve Jobs&quot;, 1234);   &#x2F;&#x2F;创建子类Employee的SteveJobs对象</span><br><span class="line"> </span><br><span class="line">     BillGates.SayHello();       &#x2F;&#x2F;通过对象直接调用到prototype的方法</span><br><span class="line">     SteveJobs.SayHello();       &#x2F;&#x2F;通过子类对象直接调用基类prototype的方法，关注！</span><br><span class="line">     SteveJobs.ShowMeTheMoney(); &#x2F;&#x2F;通过子类对象直接调用子类prototype的方法</span><br><span class="line"> </span><br><span class="line">     alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;显示：true，表明prototype的方法是共享的</span><br></pre></td></tr></table></figure>

<p>这段代码的第17行，构造了一个基类的对象，并将其设为子类构造函数的prototype，这是很有意思的。这样做的目的就是为了第28行，通过子类对象也可以直接调用基类prototype的方法。为什么可以这样呢？<br>原来，在JavaScript中，prototype不但能让对象共享自己财富，而且prototype还有寻根问祖的天性，从而使得先辈们的遗产可以代 代相传。当从一个对象那里读取属性或调用方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的prototype对象那里寻找；如果 prototype没有，又会去prototype自己关联的前辈prototype那里寻找，直到找到或追溯过程结束为止。<br>在JavaScript内部，对象的属性和方法追溯机制是通过所谓的prototype链来实现的。当用new操作符构造对象时，也会同时将构造函数的 prototype对象指派给新创建的对象，成为该对象内置的原型对象。对象内置的原型对象应该是对外不可见的，尽管有些浏览器(如Firefox)可以 让我们访问这个内置原型对象，但并不建议这样做。内置的原型对象本身也是对象，也有自己关联的原型对象，这样就形成了所谓的原型链。<br>在原型链的最末端，就是Object构造函数prototype属性指向的那一个原型对象。这个原型对象是所有对象的最老祖先，这个老祖宗实现了诸如 toString等所有对象天生就该具有的方法。其他内置构造函数，如Function, Boolean, String, Date和RegExp等的prototype都是从这个老祖宗传承下来的，但他们各自又定义了自身的属性和方法，从而他们的子孙就表现出各自宗族的那些 特征。<br>这不就是“继承”吗？是的，这就是“继承”，是JavaScript特有的“原型继承”。<br>“原型继承”是慈祥而又严厉的。原形对象将自己的属性和方法无私地贡献给孩子们使用，也并不强迫孩子们必须遵从，允许一些顽皮孩子按自己的兴趣和爱好独立 行事。从这点上看，原型对象是一位慈祥的母亲。然而，任何一个孩子虽然可以我行我素，但却不能动原型对象既有的财产，因为那可能会影响到其他孩子的利益。 从这一点上看，原型对象又象一位严厉的父亲。我们来看看下面的代码就可以理解这个意思了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)</span><br><span class="line">  &#123;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  Person.prototype.company &#x3D; &quot;Microsoft&quot;; &#x2F;&#x2F;原型的属性</span><br><span class="line">  </span><br><span class="line">  Person.prototype.SayHello &#x3D; function()  &#x2F;&#x2F;原型的方法</span><br><span class="line">  &#123;</span><br><span class="line">      alert(&quot;Hello, I&#39;m &quot; + this.name + &quot; of &quot; + this.company);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  var BillGates &#x3D; new Person(&quot;Bill Gates&quot;);</span><br><span class="line">  BillGates.SayHello();   &#x2F;&#x2F;由于继承了原型的东西，规规矩矩输出：Hello, I&#39;m Bill Gates</span><br><span class="line">  </span><br><span class="line">  var SteveJobs &#x3D; new Person(&quot;Steve Jobs&quot;);</span><br><span class="line">  SteveJobs.company &#x3D; &quot;Apple&quot;;    &#x2F;&#x2F;设置自己的company属性，掩盖了原型的company属性</span><br><span class="line">  SteveJobs.SayHello &#x3D; function() &#x2F;&#x2F;实现了自己的SayHello方法，掩盖了原型的SayHello方法</span><br><span class="line">  &#123;</span><br><span class="line">      alert(&quot;Hi, &quot; + this.name + &quot; like &quot; + this.company + &quot;, ha ha ha &quot;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  SteveJobs.SayHello();   &#x2F;&#x2F;都是自己覆盖的属性和方法，输出：Hi, Steve Jobs like Apple, ha ha ha </span><br><span class="line">  </span><br><span class="line">  BillGates.SayHello();   &#x2F;&#x2F;SteveJobs的覆盖没有影响原型对象，BillGates还是按老样子输出</span><br></pre></td></tr></table></figure>

<p>对象可以掩盖原型对象的那些属性和方法，一个构造函数原型对象也可以掩盖上层构造函数原型对象既有的属性和方法。这种掩盖其实只是在对象自己身上创建了新 的属性和方法，只不过这些属性和方法与原型对象的那些同名而已。JavaScript就是用这简单的掩盖机制实现了对象的“多态”性，与静态对象语言的虚 函数和重载(override)概念不谋而合。<br>然而，比静态对象语言更神奇的是，我们可以随时给原型对象动态添加新的属性和方法，从而动态地扩展基类的功能特性。这在静态对象语言中是很难想象的。我们来看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)</span><br><span class="line">  &#123;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  Person.prototype.SayHello &#x3D; function()  &#x2F;&#x2F;建立对象前定义的方法</span><br><span class="line">  &#123;</span><br><span class="line">      alert(&quot;Hello, I&#39;m &quot; + this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  var BillGates &#x3D; new Person(&quot;Bill Gates&quot;);   &#x2F;&#x2F;建立对象</span><br><span class="line">  </span><br><span class="line">  BillGates.SayHello();</span><br><span class="line">  </span><br><span class="line">  Person.prototype.Retire &#x3D; function()    &#x2F;&#x2F;建立对象后再动态扩展原型的方法</span><br><span class="line">  &#123;</span><br><span class="line">      alert(&quot;Poor &quot; + this.name + &quot;, bye bye!&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  BillGates.Retire(); &#x2F;&#x2F;动态扩展的方法即可被先前建立的对象立即调用</span><br></pre></td></tr></table></figure>

<p>阿弥佗佛，原型继承竟然可以玩出有这样的法术！</p>
<h2 id="原型扩展"><a href="#原型扩展" class="headerlink" title="原型扩展"></a>原型扩展</h2><p>想必君的悟性极高，可能你会这样想：如果在JavaScript内置的那些如Object和Function等函数的prototype上添加些新的方法和属性，是不是就能扩展JavaScript的功能呢？<br>那么，恭喜你，你得到了！<br>在AJAX技术迅猛发展的今天，许多成功的AJAX项目的JavaScript运行库都大量扩展了内置函数的prototype功能。比如微软的 ASP.NET AJAX，就给这些内置函数及其prototype添加了大量的新特性，从而增强了JavaScript的功能。<br>我们来看一段摘自MicrosoftAjax.debug.js中的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype.trim &#x3D; function String$trim() &#123;</span><br><span class="line">    if (arguments.length !&#x3D;&#x3D; 0) throw Error.parameterCount();</span><br><span class="line">    return this.replace(&#x2F;^\s+|\s+$&#x2F;g, &#39;&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是给内置String函数的prototype扩展了一个trim方法，于是所有的String类对象都有了trim方法了。有了这个 扩展，今后要去除字符串两段的空白，就不用再分别处理了，因为任何字符串都有了这个扩展功能，只要调用即可，真的很方便。<br> 当然，几乎很少有人去给Object的prototype添加方法，因为那会影响到所有的对象，除非在你的架构中这种方法的确是所有对象都需要的。<br>前两年，微软在设计AJAX类库的初期，用了一种被称为“闭包”(closure)的技术来模拟“类”。其大致模型如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(firstName, lastName, age)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;私有变量：</span><br><span class="line">        var _firstName &#x3D; firstName;</span><br><span class="line">        var _lastName &#x3D; lastName;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;公共变量:</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;方法：</span><br><span class="line">        this.getName &#x3D; function()</span><br><span class="line">        &#123;</span><br><span class="line">            return(firstName + &quot; &quot; + lastName);</span><br><span class="line">        &#125;;</span><br><span class="line">        this.SayHello &#x3D; function()</span><br><span class="line">        &#123;</span><br><span class="line">            alert(&quot;Hello, I&#39;m &quot; + firstName + &quot; &quot; + lastName);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    var BillGates &#x3D; new Person(&quot;Bill&quot;, &quot;Gates&quot;, 53);</span><br><span class="line">    var SteveJobs &#x3D; new Person(&quot;Steve&quot;, &quot;Jobs&quot;, 53);</span><br><span class="line">    </span><br><span class="line">    BillGates.SayHello();</span><br><span class="line">    SteveJobs.SayHello();</span><br><span class="line">    alert(BillGates.getName() + &quot; &quot; + BillGates.age);</span><br><span class="line">    alert(BillGates.firstName);     &#x2F;&#x2F;这里不能访问到私有变量</span><br></pre></td></tr></table></figure>

<p>很显然，这种模型的类描述特别象C#语言的描述形式，在一个构造函数里依次定义了私有成员、公共属性和可用的方法，显得非常优雅嘛。特别是“闭包”机制可以模拟对私有成员的保护机制，做得非常漂亮。<br>所谓的“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层外层函数体中的临时变量。这使得 只要目标对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失 了，但在目标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量 只是对应新的值，和上次那次调用的是各自独立的。的确很巧妙！<br>但是前面我们说过，给每一个对象设置一份方法是一种很大的浪费。还有，“闭包”这种间接保持变量值的机制，往往会给JavaSript的垃圾回收 器制造难题。特别是遇到对象间复杂的循环引用时，垃圾回收的判断逻辑非常复杂。无独有偶，IE浏览器早期版本确实存在JavaSript垃圾回收方面的内 存泄漏问题。再加上“闭包”模型在性能测试方面的表现不佳，微软最终放弃了“闭包”模型，而改用“原型”模型。正所谓“有得必有失”嘛。<br>原型模型需要一个构造函数来定义对象的成员，而方法却依附在该构造函数的原型上。大致写法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义构造函数</span><br><span class="line">    function Person(name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name &#x3D; name;   &#x2F;&#x2F;在构造函数中定义成员</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;方法定义到构造函数的prototype上</span><br><span class="line">    Person.prototype.SayHello &#x3D; function()</span><br><span class="line">    &#123;</span><br><span class="line">        alert(&quot;Hello, I&#39;m &quot; + this.name);</span><br><span class="line">    &#125;;    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;子类构造函数</span><br><span class="line">    function Employee(name, salary)</span><br><span class="line">    &#123;</span><br><span class="line">        Person.call(this, name);    &#x2F;&#x2F;调用上层构造函数</span><br><span class="line">        this.salary &#x3D; salary;       &#x2F;&#x2F;扩展的成员</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;子类构造函数首先需要用上层构造函数来建立prototype对象，实现继承的概念</span><br><span class="line">    Employee.prototype &#x3D; new Person()   &#x2F;&#x2F;只需要其prototype的方法，此对象的成员没有任何意义！</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;子类方法也定义到构造函数之上</span><br><span class="line">    Employee.prototype.ShowMeTheMoney &#x3D; function()</span><br><span class="line">    &#123;</span><br><span class="line">        alert(this.name + &quot; $&quot; + this.salary);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    var BillGates &#x3D; new Person(&quot;Bill Gates&quot;);</span><br><span class="line">    BillGates.SayHello();    </span><br><span class="line">    </span><br><span class="line">    var SteveJobs &#x3D; new Employee(&quot;Steve Jobs&quot;, 1234);</span><br><span class="line">    SteveJobs.SayHello();</span><br><span class="line">    SteveJobs.ShowMeTheMoney();</span><br></pre></td></tr></table></figure>

<p>原型类模型虽然不能模拟真正的私有变量，而且也要分两部分来定义类，显得不怎么“优雅”。不过，对象间的方法是共享的，不会遇到垃圾回收问题，而且性能优于“闭包”模型。正所谓“有失必有得”嘛。<br>在原型模型中，为了实现类继承，必须首先将子类构造函数的prototype设置为一个父类的对象实例。创建这个父类对象实例的目的就是为 了构成原型链，以起到共享上层原型方法作用。但创建这个实例对象时，上层构造函数也会给它设置对象成员，这些对象成员对于继承来说是没有意义的。虽然，我 们也没有给构造函数传递参数，但确实创建了若干没有用的成员，尽管其值是undefined，这也是一种浪费啊。<br>唉！世界上没有完美的事情啊！</p>
<h2 id="原型真谛"><a href="#原型真谛" class="headerlink" title="原型真谛"></a>原型真谛</h2><p>正当我们感概万分时，天空中一道红光闪过，祥云中出现了观音菩萨。只见她手持玉净瓶，轻拂翠柳枝，洒下几滴甘露，顿时让JavaScript又添新的灵气。<br>观音洒下的甘露在JavaScript的世界里凝结成块，成为了一种称为“语法甘露”的东西。这种语法甘露可以让我们编写的代码看起来更象对象语言。<br>要想知道这“语法甘露”为何物，就请君侧耳细听。<br>在理解这些语法甘露之前，我们需要重新再回顾一下JavaScript构造对象的过程。<br>我们已经知道，用 var anObject = new aFunction() 形式创建对象的过程实际上可以分为三步：第一步是建立一个新对象；第二步将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象；第 三步就是将该对象作为this参数调用构造函数，完成成员设置等初始化工作。对象建立之后，对象上的任何访问和操作都只与对象自身及其原型链上的那串对象 有关，与构造函数再扯不上关系了。换句话说，构造函数只是在创建对象时起到介绍原型对象和初始化对象两个作用。<br>那么，我们能否自己定义一个对象来当作原型，并在这个原型上描述类，然后将这个原型设置给新创建的对象，将其当作对象的类呢？我们又能否将这个原型中的一个方法当作构造函数，去初始化新建的对象呢？例如，我们定义这样一个原型对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Person &#x3D;  &#x2F;&#x2F;定义一个对象来作为原型类</span><br><span class="line">  &#123;</span><br><span class="line">      Create: function(name, age)  &#x2F;&#x2F;这个当构造函数</span><br><span class="line">      &#123;</span><br><span class="line">          this.name &#x3D; name;</span><br><span class="line">          this.age &#x3D; age;</span><br><span class="line">      &#125;,</span><br><span class="line">      SayHello: function()  &#x2F;&#x2F;定义方法</span><br><span class="line">      &#123;</span><br><span class="line">          alert(&quot;Hello, I&#39;m &quot; + this.name);</span><br><span class="line">      &#125;,</span><br><span class="line">      HowOld: function()  &#x2F;&#x2F;定义方法</span><br><span class="line">      &#123;</span><br><span class="line">          alert(this.name + &quot; is &quot; + this.age + &quot; years old.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>这个JSON形式的写法多么象一个C#的类啊！既有构造函数，又有各种方法。如果可以用某种形式来创建对象，并将对象的内置的原型设置为上面这个“类”对象，不就相当于创建该类的对象了吗？<br>但遗憾的是，我们几乎不能访问到对象内置的原型属性！尽管有些浏览器可以访问到对象的内置原型，但这样做的话就只能限定了用户必须使用那种浏览器。这也几乎不可行。<br>那么，我们可不可以通过一个函数对象来做媒介，利用该函数对象的prototype属性来中转这个原型，并用new操作符传递给新建的对象呢？<br>其实，象这样的代码就可以实现这一目标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function anyfunc()&#123;&#125;;           &#x2F;&#x2F;定义一个函数躯壳</span><br><span class="line">   anyfunc.prototype &#x3D; Person;     &#x2F;&#x2F;将原型对象放到中转站prototype</span><br><span class="line">   var BillGates &#x3D; new anyfunc();  &#x2F;&#x2F;新建对象的内置原型将是我们期望的原型对象</span><br></pre></td></tr></table></figure>

<p>不过，这个anyfunc函数只是一个躯壳，在使用过这个躯壳之后它就成了多余的东西了，而且这和直接使用构造函数来创建对象也没啥不同，有点不爽。<br>可是，如果我们将这些代码写成一个通用函数，而那个函数躯壳也就成了函数内的函数，这个内部函数不就可以在外层函数退出作用域后自动消亡吗？而且，我们可以将原型对象作为通用函数的参数，让通用函数返回创建的对象。我们需要的就是下面这个形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function New(aClass, aParams)    &#x2F;&#x2F;通用创建函数</span><br><span class="line">   &#123;</span><br><span class="line">       function new_()     &#x2F;&#x2F;定义临时的中转函数壳</span><br><span class="line">       &#123;</span><br><span class="line">           aClass.Create.apply(this, aParams);   &#x2F;&#x2F;调用原型中定义的的构造函数，中转构造逻辑及构造参数</span><br><span class="line">       &#125;;</span><br><span class="line">       new_.prototype &#x3D; aClass;    &#x2F;&#x2F;准备中转原型对象</span><br><span class="line">       return new new_();          &#x2F;&#x2F;返回建立最终建立的对象</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   var Person &#x3D;        &#x2F;&#x2F;定义的类</span><br><span class="line">   &#123;</span><br><span class="line">       Create: function(name, age)</span><br><span class="line">       &#123;</span><br><span class="line">           this.name &#x3D; name;</span><br><span class="line">           this.age &#x3D; age;</span><br><span class="line">       &#125;,</span><br><span class="line">       SayHello: function()</span><br><span class="line">       &#123;</span><br><span class="line">           alert(&quot;Hello, I&#39;m &quot; + this.name);</span><br><span class="line">       &#125;,</span><br><span class="line">       HowOld: function()</span><br><span class="line">       &#123;</span><br><span class="line">           alert(this.name + &quot; is &quot; + this.age + &quot; years old.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   var BillGates &#x3D; New(Person, [&quot;Bill Gates&quot;, 53]);  &#x2F;&#x2F;调用通用函数创建对象，并以数组形式传递构造参数</span><br><span class="line">   BillGates.SayHello();</span><br><span class="line">   BillGates.HowOld();</span><br><span class="line"></span><br><span class="line">   alert(BillGates.constructor &#x3D;&#x3D; Object);     &#x2F;&#x2F;输出：true</span><br></pre></td></tr></table></figure>

<p>这里的通用函数New()就是一个“语法甘露”！这个语法甘露不但中转了原型对象，还中转了构造函数逻辑及构造参数。<br>有趣的是，每次创建完对象退出New函数作用域时，临时的new_函数对象会被自动释放。由于new_的prototype属性被设置为新的原型 对象，其原来的原型对象和new_之间就已解开了引用链，临时函数及其原来的原型对象都会被正确回收了。上面代码的最后一句证明，新创建的对象的 constructor属性返回的是Object函数。其实新建的对象自己及其原型里没有constructor属性，那返回的只是最顶层原型对象的构造 函数，即Object。<br>有了New这个语法甘露，类的定义就很像C#那些静态对象语言的形式了，这样的代码显得多么文静而优雅啊！<br>当然，这个代码仅仅展示了“语法甘露”的概念。我们还需要多一些的语法甘露，才能实现用简洁而优雅的代码书写类层次及其继承关系。好了，我们再来看一个更丰富的示例吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;语法甘露：</span><br><span class="line">  var object &#x3D;    &#x2F;&#x2F;定义小写的object基本类，用于实现最基础的方法等</span><br><span class="line">  &#123;</span><br><span class="line">      isA: function(aType)   &#x2F;&#x2F;一个判断类与类之间以及对象与类之间关系的基础方法</span><br><span class="line">      &#123;</span><br><span class="line">          var self &#x3D; this;</span><br><span class="line">          while(self)</span><br><span class="line">          &#123;</span><br><span class="line">              if (self &#x3D;&#x3D; aType)</span><br><span class="line">                return true;</span><br><span class="line">              self &#x3D; self.Type;</span><br><span class="line">          &#125;;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  function Class(aBaseClass, aClassDefine)    &#x2F;&#x2F;创建类的函数，用于声明类及继承关系</span><br><span class="line">  &#123;</span><br><span class="line">      function class_()   &#x2F;&#x2F;创建类的临时函数壳</span><br><span class="line">      &#123;</span><br><span class="line">          this.Type &#x3D; aBaseClass;    &#x2F;&#x2F;我们给每一个类约定一个Type属性，引用其继承的类</span><br><span class="line">          for(var member in aClassDefine)</span><br><span class="line">              this[member] &#x3D; aClassDefine[member];    &#x2F;&#x2F;复制类的全部定义到当前创建的类</span><br><span class="line">      &#125;;</span><br><span class="line">      class_.prototype &#x3D; aBaseClass;</span><br><span class="line">      return new class_();</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  function New(aClass, aParams)   &#x2F;&#x2F;创建对象的函数，用于任意类的对象创建</span><br><span class="line">  &#123;</span><br><span class="line">      function new_()     &#x2F;&#x2F;创建对象的临时函数壳</span><br><span class="line">      &#123;</span><br><span class="line">          this.Type &#x3D; aClass;    &#x2F;&#x2F;我们也给每一个对象约定一个Type属性，据此可以访问到对象所属的类</span><br><span class="line">          if (aClass.Create)</span><br><span class="line">            aClass.Create.apply(this, aParams);   &#x2F;&#x2F;我们约定所有类的构造函数都叫Create，这和DELPHI比较相似</span><br><span class="line">      &#125;;</span><br><span class="line">      new_.prototype &#x3D; aClass;</span><br><span class="line">      return new new_();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;语法甘露的应用效果：    </span><br><span class="line">  var Person &#x3D; Class(object,      &#x2F;&#x2F;派生至object基本类</span><br><span class="line">  &#123;</span><br><span class="line">      Create: function(name, age)</span><br><span class="line">      &#123;</span><br><span class="line">          this.name &#x3D; name;</span><br><span class="line">          this.age &#x3D; age;</span><br><span class="line">      &#125;,</span><br><span class="line">      SayHello: function()</span><br><span class="line">      &#123;</span><br><span class="line">          alert(&quot;Hello, I&#39;m &quot; + this.name + &quot;, &quot; + this.age + &quot; years old.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  var Employee &#x3D; Class(Person,    &#x2F;&#x2F;派生至Person类，是不是和一般对象语言很相似？</span><br><span class="line">  &#123;</span><br><span class="line">      Create: function(name, age, salary)</span><br><span class="line">      &#123;</span><br><span class="line">          Person.Create.call(this, name, age);  &#x2F;&#x2F;调用基类的构造函数</span><br><span class="line">          this.salary &#x3D; salary;</span><br><span class="line">      &#125;,</span><br><span class="line">      ShowMeTheMoney: function()</span><br><span class="line">      &#123;</span><br><span class="line">          alert(this.name + &quot; $&quot; + this.salary);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  var BillGates &#x3D; New(Person, [&quot;Bill Gates&quot;, 53]);</span><br><span class="line">  var SteveJobs &#x3D; New(Employee, [&quot;Steve Jobs&quot;, 53, 1234]);</span><br><span class="line">  BillGates.SayHello();</span><br><span class="line">  SteveJobs.SayHello();</span><br><span class="line">  SteveJobs.ShowMeTheMoney();</span><br><span class="line">  </span><br><span class="line">  var LittleBill &#x3D; New(BillGates.Type, [&quot;Little Bill&quot;, 6]);   &#x2F;&#x2F;根据BillGate的类型创建LittleBill</span><br><span class="line">  LittleBill.SayHello();</span><br><span class="line">  </span><br><span class="line">  alert(BillGates.isA(Person));       &#x2F;&#x2F;true</span><br><span class="line">  alert(BillGates.isA(Employee));     &#x2F;&#x2F;false</span><br><span class="line">  alert(SteveJobs.isA(Person));       &#x2F;&#x2F;true</span><br><span class="line">  alert(Person.isA(Employee));        &#x2F;&#x2F;false</span><br><span class="line">  alert(Employee.isA(Person));        &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>“语法甘露”不用太多，只要那么一点点，就能改观整个代码的易读性和流畅性，从而让代码显得更优雅。有了这些语法甘露，JavaScript就很像一般对象语言了，写起代码了感觉也就爽多了！<br>令人高兴的是，受这些甘露滋养的JavaScript程序效率会更高。因为其原型对象里既没有了毫无用处的那些对象级的成员，而且还不存在 constructor属性体，少了与构造函数间的牵连，但依旧保持了方法的共享性。这让JavaScript在追溯原型链和搜索属性及方法时，少费许多 工夫啊。<br>我们就把这种形式称为“甘露模型”吧！其实，这种“甘露模型”的原型用法才是符合prototype概念的本意，才是的JavaScript原型的真谛！<br>想必微软那些设计AJAX架构的工程师看到这个甘露模型时，肯定后悔没有早点把AJAX部门从美国搬到咱中国的观音庙来，错过了观音菩萨的点化。 当然，我们也只能是在代码的示例中，把Bill Gates当作对象玩玩，真要让他放弃上帝转而皈依我佛肯定是不容易的，机缘未到啊！如果哪天你在微软新出的AJAX类库中看到这种甘露模型，那才是真正 的缘分！</p>
<h2 id="编程的快乐"><a href="#编程的快乐" class="headerlink" title="编程的快乐"></a>编程的快乐</h2><p>在软件工业迅猛发展的今天，各式各样的编程语言层出不穷，新语言的诞生，旧语言的演化，似乎已经让我们眼花缭乱。为了适应面向对象编程的潮 流，JavaScript语言也在向完全面向对象的方向发展，新的JavaScript标准已经从语义上扩展了许多面向对象的新元素。与此相反的是，许多 静态的对象语言也在向JavaScript的那种简洁而幽雅的方向发展。例如，新版本的C#语言就吸收了JSON那样的简洁表示法，以及一些其他形式的 JavaScript特性。<br>我们应该看到，随着RIA(强互联应用)的发展和普及，AJAX技术也将逐渐淡出江湖，JavaScript也将最终消失或演化成其他形式的语 言。但不管编程语言如何发展和演化，编程世界永远都会在“数据”与“代码”这千丝万缕的纠缠中保持着无限的生机。只要我们能看透这一点，我们就能很容易地 学习和理解软件世界的各种新事物。不管是已熟悉的过程式编程，还是正在发展的函数式编程，以及未来量子纠缠态的大规模并行式编程，我们都有足够的法力来化 解一切复杂的难题。<br>佛最后淡淡地说：只要我们放下那些表面的“类”，放下那些对象的“自我”，就能达到一种“对象本无根，类型亦无形”的境界，从而将自我融入到整个 宇宙的生命轮循环中。我们将没有自我，也没有自私的欲望，你就是我，我就是你，你中有我，我中有你。这时，我们再看这生机勃勃的编程世界时，我们的内心将 自然生起无限的慈爱之心，这种慈爱之心不是虚伪而是真诚的。关爱他人就是关爱自己，就是关爱这世界中的一切。那么，我们的心是永远快乐的，我们的程序是永 远快乐的，我们的类是永远快乐的，我们的对象也是永远快乐的。这就是编程的极乐！<br>说到这里，在座的比丘都犹如醍醐灌顶，心中豁然开朗。看看左边这位早已喜不自禁，再看看右边那位也是心花怒放。<br>蓦然回首时，唯见君拈花微笑…</p>
<h2 id="原著：李战-leadzen-深圳"><a href="#原著：李战-leadzen-深圳" class="headerlink" title="原著：李战(leadzen).深圳"></a>原著：李战(leadzen).深圳</h2>]]></content>
      <categories>
        <category>摘要</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
